#include "NameReg.h"void KDRV_InitRegProperty(KDRV_RegProperty *prop, char *in_name, int in_size){	assert(strlen(in_name) < 32);	strcpy(prop->name, in_name);	prop->valueSize = in_size;}OSErr KDRV_RegPropertyGet(RegEntryID *regEntry, KDRV_RegProperty *prop){	return RegistryPropertyGet(		regEntry,		prop->name,		(void *)(prop->valueStr32),	// ptr to the union data field		&prop->valueSize	);}OSErr KDRV_FindPCICardByName(RegEntryID *foundEntry, char *searchname){	OSErr err = noErr;	RegEntryIter cookie;	Boolean done;		// Entry iterators are created from the root value.	RegEntryIterationOp op = kRegIterContinue;		// (example code from Designing PCI Cards and Drivers PDF)	err = RegistryEntryIterateCreate(&cookie);	if(err == noErr)	{		// Iterate over the Name Registry until we find a matching entry.		do		{			RegEntryID entry;						err = RegistryEntryIterate(&cookie, op, &entry, &done);			if(!done)			{				RegCStrPathName *name;				RegPathNameSize len;								err = RegistryEntryToPathSize(&entry, &len);				if(err == noErr)				{					name = (RegCStrPathName *)malloc(len);					assert(name != NULL);										err = RegistryCStrEntryToPath(&entry, name, len);					if(err == noErr)					{						// Is this the Sonnet Tango?						int length = strlen(searchname);						char *match = strstr(name, searchname);																if(match != NULL)						{							if(match[length] == 0)							{								RegistryEntryIDCopy(&entry, foundEntry);							}						}					}					free(name);				}				RegistryEntryIDDispose(&entry);			}		} while(!done);		RegistryEntryIterateDispose(&cookie);		return err;	}		return 1;}