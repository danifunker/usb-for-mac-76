#include "PCIDevice.h"void PCI_PopulatePCIDevice(PCIDevice *device, RegEntryID *regEntryID){	// If we had multiple memory regions, we would need to resolve vectors here.	KDRV_RegProperty	propSlotName,						propAssignedAddress,						propLogicalAddress,						propIST;						KDRV_InitRegProperty(&propSlotName, "AAPL,slot-name", sizeof(Str31));		KDRV_InitRegProperty(&propAssignedAddress, "assigned-addresses", sizeof(UInt32));	KDRV_InitRegProperty(&propLogicalAddress, kAAPLDeviceLogicalAddress, sizeof(UInt32));	KDRV_InitRegProperty(&propIST, kISTPropertyName, sizeof(ISTProperty));		KDRV_RegPropertyGet(regEntryID, &propSlotName);	KDRV_RegPropertyGet(regEntryID, &propAssignedAddress);	KDRV_RegPropertyGet(regEntryID, &propLogicalAddress);	KDRV_RegPropertyGet(regEntryID, &propIST);		// We only have one memory region in an OHCI controller, so use the first address entry.			// The card must be brought onto the memory bus by setting BIT 1 of the COMMAND REGISTER	// in configuration space (0x04)	// Otherwise you'll get a bus error because the card won't respond to memory cycles.	RegistryEntryIDCopy(regEntryID, &device->node);	device->physBase = (void *)propAssignedAddress.valueUint32;	device->logicalBase = (void *)propLogicalAddress.valueUint32;		device->ohci.regs = (OHCI_Regs *)device->logicalBase;		for(int i=0; i<2; i++)	{		device->istMembers[i].setID 	= propIST.valueISTProperty[i].setID;		device->istMembers[i].member 	= propIST.valueISTProperty[i].member;	}			printf("Found OHCI controller in PCI slot %s. Phys %08X, Virt %08X\n", 		propSlotName.valueStr32, propAssignedAddress.valueUint32, propLogicalAddress.valueUint32);}