/* *  Hello World for the CodeWarrior *  © 1997-1998 Metrowerks Corp. * *  Questions and comments to: *       <mailto:support@metrowerks.com> *       <http://www.metrowerks.com/> */#include "Main.h"#include <SIOUX.h>PCIDevice pciSonnet;RegEntryID sonnetRegEntryID;Boolean gDone;int main(void){	SIOUXSettings.standalone = true;	gDone = false;	OSErr result;		result = KDRV_FindPCICardByName(&sonnetRegEntryID, SONNET_TANGO_GESTALT_NAME);		//TIME_DebugDumpTimeBase();		if(result == 0)	{		PCI_PopulatePCIDevice(&pciSonnet, &sonnetRegEntryID);	}	else	{		return 0;	}		// bring the card online	{		UInt16 configWord;		ExpMgrConfigReadWord(&pciSonnet.node, (LogicalAddress)0x04, &configWord);		configWord = configWord | 0x02;		ExpMgrConfigWriteWord(&pciSonnet.node, (LogicalAddress)0x04, configWord);	};		// try reading the revision value	OHCI_ResetHC(&pciSonnet.ohci); // Reset the host controller.	OHCI_DebugPrintControllerState(&pciSonnet.ohci);			UInt32 rootHubDescA = OHCI_GetRegisterValue(&pciSonnet.ohci, OHCI_REG_HCRHDESCRIPTORA);	pciSonnet.ohci.rootPortCount = rootHubDescA & 0xFF;			// Now follow the instructions in Section 5 to initialize the host controller.		// "Initialize the device data HCCA block to match the current device data state"	// "Initialize the Operational Registers to match the current device data state"	OHCI_InitializeMemoryRegions(&pciSonnet.ohci);		// provide the HCCA address to the host controller	OHCI_SetRegisterValue(&pciSonnet.ohci, OHCI_REG_HCHCCA, (UInt32)pciSonnet.ohci.hcca);		// Install our ISR.	OHCI_InstallISR(&pciSonnet.ohci, pciSonnet.node, pciSonnet.istMembers);	printf("- ISR installed\n");		// Enable master interrupt bit and any other interrupts we need.	//OHCI_SetRegisterValue(&pciSonnet.ohci, OHCI_REG_HCINTERRUPTENABLE, OHCI_INTFLAG_SF|OHCI_INTFLAG_MIE);		// Set controller to UsbOperational.	UInt32 control = OHCI_GetRegisterValue(&pciSonnet.ohci, OHCI_REG_HCCONTROL);	OHCI_HcControlBits *controlBits = (OHCI_HcControlBits *)&control;	controlBits->functional_state = 2;	control = control & ~((1 << 6)|(1 << 7));	control = control | (1 << 7);	control = control | 0x10; // control list enabled	OHCI_SetRegisterValue(&pciSonnet.ohci, OHCI_REG_HCCONTROL, control);		OHCI_DebugPrintControllerState(&pciSonnet.ohci);		for(int i=1; i<pciSonnet.ohci.rootPortCount; i++)	{		OHCI_PowerPort(&pciSonnet.ohci, i, true);		OHCI_EnablePort(&pciSonnet.ohci, i, true);		UInt32 portStatus = OHCI_GetRegisterValue(&pciSonnet.ohci, (OHCI_RegisterIndex)(OHCI_REG_HCRHPORTSTATUS_0+i));				portStatus = OHCI_GetRegisterValue(&pciSonnet.ohci, (OHCI_RegisterIndex)(OHCI_REG_HCRHPORTSTATUS_0+i));		printf("- Root port %d, device connected %d (status %08X)\n", i, (portStatus & 1), portStatus);			if(portStatus & 1)		{			pciSonnet.ohci.ports[i].connected = true;		}		else		{			pciSonnet.ohci.ports[i].connected = false;		}	}		// Enable all interrupts except SOF detect.		// Enable all queues.		CheckpointIO(pciSonnet.ohci.ioPrepTable.preparationID, kNextIOIsInput|kMoreIOTransfers);			char *setup_packet = (char *)((UInt32)(pciSonnet.ohci.dma_base.logical) + 1024);	char *response = (char *)((UInt32)(pciSonnet.ohci.dma_base.logical) + 2048);	setup_packet[0] = 0x80;	setup_packet[1] = 0x06;	setup_packet[2] = 0x00;	setup_packet[3] = 0x01;	setup_packet[4] = 0x00;	setup_packet[5] = 0x00;	setup_packet[6] = 0x12;	setup_packet[7] = 0x00;	OHCI_GeneralTD *td = OHCI_GeneralTD_Create();		OHCI_GeneralTD_Init(td, 0, setup_packet, 8);	OHCI_TD_SetDataToggle(td, 2);	OHCI_ED_AttachTD(pciSonnet.ohci.listControl, td);		OHCI_GeneralTD_Init(td, 2, response, 8);	OHCI_TD_SetDataToggle(td, 3);	OHCI_ED_AttachTD(pciSonnet.ohci.listControl, td);		OHCI_GeneralTD_Init(td, 2, response+8, 8);	OHCI_TD_SetDataToggle(td, 2);	OHCI_ED_AttachTD(pciSonnet.ohci.listControl, td);		OHCI_ED_SetFunctionAddress(pciSonnet.ohci.listControl, 0);	OHCI_ED_SetMaxPacketSize(pciSonnet.ohci.listControl, 64);	//OHCI_ED_DumpInfo(pciSonnet.ohci.listControl);	//OHCI_TD_DumpList(OHCI_ED_GetHeadP(pciSonnet.ohci.listControl));	CheckpointIO(pciSonnet.ohci.ioPrepTable.preparationID, kNextIOIsOutput|kMoreIOTransfers);	printf("*** Triggering control list processing...\n");	UInt32 commandStatus = OHCI_GetRegisterValue(&pciSonnet.ohci, OHCI_REG_HCCOMMANDSTATUS);	commandStatus |= 0x02; // control list filled	OHCI_SetRegisterValue(&pciSonnet.ohci, OHCI_REG_HCCOMMANDSTATUS, commandStatus);		CheckpointIO(pciSonnet.ohci.ioPrepTable.preparationID, kNextIOIsOutput|kMoreIOTransfers);	DelayFor(5);			//OHCI_ED_DumpInfo(pciSonnet.ohci.listControl);	//OHCI_TD_DumpList(OHCI_ED_GetHeadP(pciSonnet.ohci.listControl));	printf("*** descriptor ***\n");	OHCI_DeviceDescriptor *devDesc = (OHCI_DeviceDescriptor *)response;	printf("Type		: %d\n", devDesc->bDescriptorType);	printf("USB Version : USB %X.%X\n", EndianU16_LtoB(devDesc->bcdUSB) >> 8, EndianU16_LtoB(devDesc->bcdUSB) & 0xFF);	printf("Class		: 0x%02X\n", devDesc->bDeviceClass);	printf("Subclass	: 0x%02X\n", devDesc->bDeviceSubClass);	printf("Packet Size	: %d\n", devDesc->bMaxPacketSize);	printf("Vendor		: 0x%04X\n", EndianU16_LtoB(devDesc->idVendor));	printf("Product		: 0x%04X\n", EndianU16_LtoB(devDesc->idProduct));	printf("Device ID   : 0x%04X\n", EndianU16_LtoB(devDesc->bcdDevice));					MAIN_EventLoop();					return 0;}void MAIN_ProcessEvent(EventRecord *event){}void USB_EventLoop(){	// Debugging, using polling instead of the ISR.	// Check the interrupt flags.	UInt32 interruptFlags = OHCI_GetRegisterValue(&pciSonnet.ohci, OHCI_REG_HCINTERRUPTSTATUS);		// RootHubStatusChange	if(interruptFlags & OHCI_INTFLAG_RHSC)	{		OHCI_EVENT_PortStatusChanged(&pciSonnet.ohci);		OHCI_SetRegisterValue(&pciSonnet.ohci, OHCI_REG_HCINTERRUPTSTATUS, OHCI_INTFLAG_RHSC);	}}void MAIN_EventLoop(){	EventRecord event;	RgnHandle cursorRgn;	Boolean gotEvent,			SIOUXProcessedIt,			interruptFlag;			cursorRgn = NewRgn();		gotEvent = false;	SIOUXProcessedIt = false;	interruptFlag = false;		do	{		gotEvent = WaitNextEvent(everyEvent, &event, 1, cursorRgn);				if(gotEvent)		{			SIOUXProcessedIt = SIOUXHandleOneEvent(&event); // if it's a SIOUX event, use SIOUX			if(!SIOUXProcessedIt)				MAIN_ProcessEvent(&event);		}				USB_EventLoop();	}	while (!gDone);}