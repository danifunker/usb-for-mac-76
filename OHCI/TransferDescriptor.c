#include ":OHCI:TransferDescriptor.h"#include <Endian.h>OHCI_GeneralTD *ohci_transfer_descriptor_pool;UInt32 OHCI_TD_InitPool(LogicalAddress base){	// Allocate an aligned, physically contiguous block for our object pool.	printf("Initializing TD object pool at %p: %d bytes\n", base, sizeof(OHCI_GeneralTD) * OHCI_TD_POOL_SIZE);		ohci_transfer_descriptor_pool = (OHCI_GeneralTD *)base;	for(int i=0; i<OHCI_TD_POOL_SIZE; i++)	{		OHCI_TD_SetUsed(&ohci_transfer_descriptor_pool[i], 0);	}		assert(ohci_transfer_descriptor_pool != NULL);		return 0;}OHCI_GeneralTD *OHCI_TD_GetFree(){	// Retrieve an unused TD from the pool.	for(int i=0; i<OHCI_TD_POOL_SIZE; i++)	{		if(OHCI_TD_GetUsed(&ohci_transfer_descriptor_pool[i]) == 0)		{			OHCI_TD_SetUsed(&ohci_transfer_descriptor_pool[i], 1);			return &ohci_transfer_descriptor_pool[i];		}	}		return NULL; // object pool is completely in use}OHCI_GeneralTD *OHCI_GeneralTD_Create(){	// Initialize a new, empty transfer descriptor.	OHCI_GeneralTD *td = OHCI_TD_GetFree();	return td;}void OHCI_GeneralTD_Init(OHCI_GeneralTD *td, int direction, Ptr buf, Size size){	if (size > 0) size = size - 1;	OHCI_TD_SetCBP(td, buf);	OHCI_TD_SetBE(td, buf+size);	OHCI_TD_SetDirection(td, direction);}void OHCI_TD_DebugDirectionStr(OHCI_GeneralTD *current, char *str){	switch(OHCI_TD_GetDirection(current))	{		case 0:			strcpy(str, "SETUP"); break;		case 1:			strcpy(str, "OUT"); break;		case 2:			strcpy(str, "IN"); break;		case 3:			strcpy(str, "RESERVED"); break;	}}void OHCI_TD_DumpList(OHCI_GeneralTD *head){	OHCI_GeneralTD *current = head;	do	{		Ptr bufStart;		Ptr bufEnd;		OHCI_GeneralTD *next;		char direction[16];		Size size;				bufStart = OHCI_TD_GetCBP(current);		bufEnd = OHCI_TD_GetBE(current);		next = OHCI_TD_GetNextTD(current);		size = bufEnd - bufStart + 1;				OHCI_TD_DebugDirectionStr(current, direction);			printf("*** Transfer Descriptor at %p\n", current);		printf("*** Direction: %s\n", direction);		printf("*** Buffer : %p to %p (%d bytes)\n", bufStart, bufEnd, size);		printf("*** Next TD: %p\n", next);		printf("*** Flags  : %08X\n", EndianU32_LtoB(current->__flags));			current = next;	} while (current != NULL);}Ptr OHCI_TD_GetCBP(OHCI_GeneralTD *td) { return (Ptr)EndianU32_BtoL(td->__CBP); }Ptr OHCI_TD_GetBE(OHCI_GeneralTD *td) { return (Ptr)EndianU32_BtoL(td->__BE); }OHCI_GeneralTD *OHCI_TD_GetNextTD(OHCI_GeneralTD *td) { return (OHCI_GeneralTD *)EndianU32_BtoL(td->__NextTD); }void OHCI_TD_SetCBP(OHCI_GeneralTD *td, Ptr cbp) { td->__CBP = (Ptr)(EndianU32_BtoL(cbp)); }void OHCI_TD_SetNextTD(OHCI_GeneralTD *td, OHCI_GeneralTD *next) { td->__NextTD = (OHCI_GeneralTD *)(EndianU32_BtoL(next)); }void OHCI_TD_SetBE(OHCI_GeneralTD *td, Ptr be) { td->__BE = (Ptr)(EndianU32_BtoL(be)); }// Flag settersvoid OHCI_TD_SetUsed(OHCI_GeneralTD *td, Boolean value){	UInt32 beFlags = EndianU32_LtoB(td->__flags);	value ? SET_BIT(beFlags, 0) : CLEAR_BIT(beFlags, 0);	td->__flags = EndianU32_BtoL(beFlags);}void OHCI_TD_SetConditionCode(OHCI_GeneralTD *td, UInt8 value){	UInt32 beFlags = EndianU32_LtoB(td->__flags);	beFlags &= ~(0xF << 28);	beFlags |= ((value & 0x3) << 28);	td->__flags = EndianU32_BtoL(beFlags);}void OHCI_TD_SetErrorCount(OHCI_GeneralTD *td, UInt8 value){	UInt32 beFlags = EndianU32_LtoB(td->__flags);	beFlags &= ~(0x3 << 26);	beFlags |= ((value & 0x3) << 26);	td->__flags = EndianU32_BtoL(beFlags);}void OHCI_TD_SetDataToggle(OHCI_GeneralTD *td, UInt8 value){	UInt32 beFlags = EndianU32_LtoB(td->__flags);	beFlags &= ~(0x3 << 24);	beFlags |= ((value & 0x3) << 24);	td->__flags = EndianU32_BtoL(beFlags);}void OHCI_TD_SetDelayInterrupt(OHCI_GeneralTD *td, UInt8 value){	UInt32 beFlags = EndianU32_LtoB(td->__flags);	beFlags &= ~(0x7 << 21);	beFlags |= ((value & 0x7) << 21);	td->__flags = EndianU32_BtoL(beFlags);}void OHCI_TD_SetDirection(OHCI_GeneralTD *td, UInt8 value){	UInt32 beFlags = EndianU32_LtoB(td->__flags);	beFlags &= ~(0x3 << 19);	beFlags |= ((value & 0x3) << 19);	td->__flags = EndianU32_BtoL(beFlags);}void OHCI_TD_SetBufferRounding(OHCI_GeneralTD *td, Boolean value){	UInt32 beFlags = EndianU32_LtoB(td->__flags);	value ? SET_BIT(beFlags, 18) : CLEAR_BIT(beFlags, 18);	td->__flags = EndianU32_BtoL(beFlags);}// Flag gettersBoolean OHCI_TD_GetUsed(OHCI_GeneralTD *td){	return (EndianU32_LtoB(td->__flags) & 1) != 0;}UInt8 OHCI_TD_GetDirection(OHCI_GeneralTD *td){	UInt32 beFlags = EndianU32_LtoB(td->__flags);	return ((beFlags >> 19) & 0x3);}