#include ":OHCI:EndpointDescriptor.h"#include ":OHCI:TransferDescriptor.h"OHCI_ED *ohci_endpoint_descriptor_pool;UInt32 OHCI_ED_InitPool(LogicalAddress base){	// Allocate an aligned, physically contiguous block for our object pool.	printf("Initializing ED object pool: %d bytes\n", sizeof(OHCI_ED)*OHCI_ED_POOL_SIZE);		ohci_endpoint_descriptor_pool = (OHCI_ED *)base;	for(int i=0; i<OHCI_ED_POOL_SIZE; i++)	{		OHCI_ED_SetUsed(&ohci_endpoint_descriptor_pool[i], 0);	}		assert(ohci_endpoint_descriptor_pool != NULL);		return sizeof(OHCI_ED) * OHCI_ED_POOL_SIZE;}OHCI_ED *OHCI_ED_GetFree(){	// Retrieve an unused ED from the pool.	for(int i=0; i<OHCI_ED_POOL_SIZE; i++)	{		if(OHCI_ED_GetUsed(&ohci_endpoint_descriptor_pool[i]) == 0)		{			OHCI_ED_SetUsed(&ohci_endpoint_descriptor_pool[i], 1);			return &ohci_endpoint_descriptor_pool[i];		}	}		return NULL; // object pool is completely in use}OHCI_ED *OHCI_ED_Create(){	// Create an ED with an empty TD queue.	OHCI_ED *ed = OHCI_ED_GetFree(); // Grab one from the pool.		// Initialize a new, empty transfer descriptor. Attach it to the ED.	OHCI_GeneralTD *td = OHCI_GeneralTD_Create();	OHCI_ED_AttachTD(ed, td);		OHCI_ED_SetHeadP(ed, td);	OHCI_ED_SetTailP(ed, td);	return ed;	}void OHCI_ED_AttachTD(OHCI_ED *ed, OHCI_GeneralTD *td){	// Follow the OHCI spec (section 5.2.8.2)		// Create a new placeholder TD at the tail of the list.	OHCI_GeneralTD *empty = OHCI_GeneralTD_Create();	OHCI_GeneralTD *tail = OHCI_ED_GetTailP(ed); 		// Current tail.		// Fill ed->TailP with the data from td.	if(ed->__TailP != NULL)	{		memcpy(tail, td, sizeof(OHCI_GeneralTD));				// Update the current tail's NextTD to the placeholder TD.		OHCI_TD_SetNextTD(tail, empty);	}		// Make the placeholder the new tail.	OHCI_ED_SetTailP(ed, empty);		OHCI_ED_SetMaxPacketSize(ed, 64);		// Caller is responsible for updating ControlListFilled/BulkListFilled.}void OHCI_ED_DumpInfo(OHCI_ED *ed){	printf("*** EndpointDescriptor at %p\n", ed);	printf("*** - ED in use? %d\n", OHCI_ED_GetUsed(ed));	printf("*** - Func Addr  %d\n", OHCI_ED_GetFunctionAddress(ed));	printf("*** - HeadP      %p\n", OHCI_ED_GetHeadP(ed));	printf("*** - TailP      %p\n", OHCI_ED_GetTailP(ed));	printf("*** - TD halted? %d\n", OHCI_ED_GetHalted(ed));	printf("*** - Flags      %08X\n", OHCI_ED_GetFlags(ed));	printf("*** - NextED     %p\n", OHCI_ED_GetNextED(ed));}OHCI_GeneralTD *OHCI_ED_GetTailP(OHCI_ED *ed){	return (OHCI_GeneralTD *)EndianU32_LtoB(ed->__TailP);}OHCI_GeneralTD *OHCI_ED_GetHeadP(OHCI_ED *ed){	return (OHCI_GeneralTD *)(EndianU32_LtoB(ed->__HeadP) & 0xFFFFFFFC);}OHCI_ED *OHCI_ED_GetNextED(OHCI_ED *ed){	return (OHCI_ED *)EndianU32_LtoB(ed->__NextED);}void OHCI_ED_SetTailP(OHCI_ED *ed, OHCI_GeneralTD *td){	ed->__TailP = (OHCI_GeneralTD *)EndianU32_BtoL(td);}void OHCI_ED_SetHeadP(OHCI_ED *ed, OHCI_GeneralTD *td){	ed->__HeadP = (OHCI_GeneralTD *)EndianU32_BtoL(td);}void OHCI_ED_SetNextED(OHCI_ED *ed, OHCI_ED *next){	ed->__NextED = (OHCI_ED *)EndianU32_BtoL(next);}// Flag settersvoid OHCI_ED_SetUsed(OHCI_ED *ed, Boolean value){	UInt32 beFlags = EndianU32_LtoB(ed->flags);	value ? SET_BIT(beFlags, 31) : CLEAR_BIT(beFlags, 31);	ed->flags = EndianU32_BtoL(beFlags);}void OHCI_ED_SetFunctionAddress(OHCI_ED *ed, UInt8 value){	UInt32 beFlags = EndianU32_LtoB(ed->flags);	beFlags &= ~(0x0000007F);	beFlags |= value & 0x7F;	ed->flags = EndianU32_BtoL(beFlags);}void OHCI_ED_SetEndpointNumber(OHCI_ED *ed, UInt8 value){	UInt32 beFlags = EndianU32_LtoB(ed->flags);	beFlags &= ~(0xF << 7);	beFlags |= ((value & 0xF) << 7);	ed->flags = EndianU32_BtoL(beFlags);}void OHCI_ED_SetDirection(OHCI_ED *ed, UInt8 value){	UInt32 beFlags = EndianU32_LtoB(ed->flags);	beFlags &= ~(0x3 << 11);	beFlags |= ((value & 0x3) << 11);	ed->flags = EndianU32_BtoL(beFlags);}void OHCI_ED_SetSpeed(OHCI_ED *ed, Boolean value){	UInt32 beFlags = EndianU32_LtoB(ed->flags);	value ? SET_BIT(beFlags, 13) : CLEAR_BIT(beFlags, 13);	ed->flags = EndianU32_BtoL(beFlags);}void OHCI_ED_SetSkip(OHCI_ED *ed, Boolean value){	UInt32 beFlags = EndianU32_LtoB(ed->flags);	value ? SET_BIT(beFlags, 14) : CLEAR_BIT(beFlags, 14);	ed->flags = EndianU32_BtoL(beFlags);}void OHCI_ED_SetFormat(OHCI_ED *ed, Boolean value){	UInt32 beFlags = EndianU32_LtoB(ed->flags);	value ? SET_BIT(beFlags, 15) : CLEAR_BIT(beFlags, 15);	ed->flags = EndianU32_BtoL(beFlags);}void OHCI_ED_SetMaxPacketSize(OHCI_ED *ed, UInt8 value){	UInt32 beFlags = EndianU32_LtoB(ed->flags);	beFlags &= ~(0x7FF << 16);	beFlags |= ((value & 0x7FF) << 16);	ed->flags = EndianU32_BtoL(beFlags);}void OHCI_ED_SetHalted(OHCI_ED *ed, Boolean value){	// Stored as part of HeadP, not flags	UInt32 beFlags = EndianU32_LtoB(ed->__HeadP);	value ? SET_BIT(beFlags, 0) : CLEAR_BIT(beFlags, 0);	ed->__HeadP = (OHCI_GeneralTD *)EndianU32_BtoL(beFlags);}void OHCI_ED_SetToggleCarry(OHCI_ED *ed, Boolean value){	// Stored as part of HeadP, not flags	UInt32 beFlags = EndianU32_LtoB(ed->__HeadP);	value ? SET_BIT(beFlags, 1) : CLEAR_BIT(beFlags, 1);	ed->__HeadP = (OHCI_GeneralTD *)EndianU32_BtoL(beFlags);}// Flag gettersUInt32 OHCI_ED_GetFlags(OHCI_ED *ed){	return (EndianU32_LtoB(ed->flags));}Boolean OHCI_ED_GetHalted(OHCI_ED *ed){	return (EndianU32_LtoB(ed->__HeadP) & 0x01) != 0;}Boolean OHCI_ED_GetUsed(OHCI_ED *ed){	UInt32 beFlags = EndianU32_LtoB(ed->flags);	return (beFlags & (1 << 31)) != 0;}UInt8 OHCI_ED_GetFunctionAddress(OHCI_ED *ed){	UInt32 beFlags = EndianU32_LtoB(ed->flags);	return beFlags & 0x0F;}