#include "OHCI.h"// Getter and SettersUInt32 OHCI_GetRegisterValue(OHCI_Device *device, OHCI_RegisterIndex regIdx){	return EndianSwap32Bit(((UInt32 *)device->regs)[regIdx]);}void OHCI_SetRegisterValue(OHCI_Device *device, OHCI_RegisterIndex regIdx, UInt32 value){	(((UInt32 *)device->regs)[regIdx]) = EndianSwap32Bit(value);}#define DMA_BUFFER_SIZE 16384void OHCI_InitializeMemoryRegions(OHCI_Device *device){	assert(sizeof(OHCI_GeneralTD) == 16);	assert(sizeof(OHCI_ED) == 16);		device->dma_base.logical = MEM_AllocAlignedBlock(DMA_BUFFER_SIZE, true); // 64K for our DMA buffers	device->dma_base.length = DMA_BUFFER_SIZE;		// Assign our object pools in DMA space.	MEM_PrepareForDMA(device);	OHCI_ED_InitPool((void *) ((UInt32)(device->dma_base.logical)+4096));	OHCI_TD_InitPool((void *) ((UInt32)(device->dma_base.logical)+8192));	device->hcca = (ohci_host_controller_comms_area_t *)device->dma_base.logical;		// Set up the Control List with one endpoint with direction determined by TD.	OHCI_ED *controlEdIn = OHCI_ED_Create();	device->listControl = controlEdIn;		// And use this list as the HC's Control List.	OHCI_SetRegisterValue(device, OHCI_REG_HCCONTROLHEADED, (UInt32)device->listControl);}void OHCI_ResetHC(OHCI_Device *device){	// Reset the host controller.	UInt32 frameInterval, periodicStart;		// Preserve frame interval.	frameInterval = OHCI_GetRegisterValue(device, OHCI_REG_HCFMINTERVAL);		// Pulse the reset bit to initialize registers and set it to Suspend mode.	OHCI_PulseResetBit(device);		// Disable all interrupts and HcControl list processing bits.	OHCI_SetRegisterValue(device, OHCI_REG_HCINTERRUPTDISABLE, OHCI_INTFLAG_ALLFLAGS);	UInt32 control = OHCI_GetRegisterValue(device, OHCI_REG_HCCONTROL);	control = (control & ~0x3F);	OHCI_SetRegisterValue(device, OHCI_REG_HCCONTROL, control);		// Initialize memory registers.	OHCI_SetRegisterValue(device, OHCI_REG_HCHCCA, (UInt32)device->hcca);		// Initialize frame registers.	#define FRAMEINTERVAL 0x2EDF	#define FSMPS ( ( 6 * (FRAMEINTERVAL-210) ) / 7 )	OHCI_SetRegisterValue(device, OHCI_REG_HCFMINTERVAL, frameInterval | (FSMPS << 16) | 0x80000000);		periodicStart = frameInterval * 0.9;		OHCI_SetRegisterValue(device, OHCI_REG_HCPERIODICSTART, periodicStart);}Boolean OHCI_PulseResetBit(OHCI_Device *device){	// Hit the reset bit in HcCommandStatus, wait 1ms for it to clear.	OHCI_SetRegisterValue(device, OHCI_REG_HCCOMMANDSTATUS, 1);	DelayFor(1); // 1 ms	return OHCI_GetRegisterValue(device, OHCI_REG_HCCOMMANDSTATUS);}void OHCI_DebugPrintControllerState(OHCI_Device *device){	UInt32 control = OHCI_GetRegisterValue(device, OHCI_REG_HCCONTROL);	int state = ((control & 0xC0) >> 6);	switch(state)	{		case 0:			printf("- Host Controller functional state: UsbReset\n");			break;		case 1:			printf("- Host Controller functional state: UsbResume\n");			break;		case 2:			printf("- Host Controller functional state: UsbOperational\n");			break;		case 3:			printf("- Host Controller functional state: UsbSuspend\n");			break;		}}/* Port controls */void OHCI_PowerPort(OHCI_Device *device, int portNum, Boolean state){	printf("Powering port %d: %d\n", portNum, state);	UInt32 reg = OHCI_GetRegisterValue(device, (OHCI_RegisterIndex)(OHCI_REG_HCRHPORTSTATUS_0+portNum));		if(state == true)	{		reg |= 0x0100;	}	else	{		reg &= (~0x0100);	}	OHCI_SetRegisterValue(device, (OHCI_RegisterIndex)(OHCI_REG_HCRHPORTSTATUS_0+portNum), reg);	DelayFor(2);}void OHCI_ResetPort(OHCI_Device *device, int portNum){	printf("Resetting port %d\n", portNum);		UInt32 reg = OHCI_GetRegisterValue(device, (OHCI_RegisterIndex)(OHCI_REG_HCRHPORTSTATUS_0+portNum));	reg |= 0x0010;		OHCI_SetRegisterValue(device, (OHCI_RegisterIndex)(OHCI_REG_HCRHPORTSTATUS_0+portNum), reg);	DelayFor(50); // 50ms, just to be safe		reg = OHCI_GetRegisterValue(device, (OHCI_RegisterIndex)(OHCI_REG_HCRHPORTSTATUS_0+portNum));		if(reg & 0x00100000)	{		reg |= 0x00100000;		OHCI_SetRegisterValue(device, (OHCI_RegisterIndex)(OHCI_REG_HCRHPORTSTATUS_0+portNum), reg);	}	else	{		printf("Failed to reset port %d\n", portNum);	}	}void OHCI_EnablePort(OHCI_Device *device, int portNum, Boolean state){	printf("Enabling port %d: %d\n", portNum, state);	UInt32 reg = OHCI_GetRegisterValue(device, (OHCI_RegisterIndex)(OHCI_REG_HCRHPORTSTATUS_0+portNum));		if(state == true)	{		reg |= 0x0002;	}	else	{		reg &= (~0x0002);	}	OHCI_SetRegisterValue(device, (OHCI_RegisterIndex)(OHCI_REG_HCRHPORTSTATUS_0+portNum), reg);	DelayFor(2);}// OHCI events - entry points from the interrupt loop.void OHCI_EVENT_DeviceConnected(OHCI_Device *device, int portNum){	OHCI_DebugPrintControllerState(device);	CheckpointIO(device->ioPrepTable.preparationID, kNextIOIsInput|kMoreIOTransfers);			char *setup_packet = (char *)((UInt32)(device->dma_base.logical) + 1024);	char *response = (char *)((UInt32)(device->dma_base.logical) + 2048);	setup_packet[0] = 0x80;	setup_packet[1] = 0x06;	setup_packet[2] = 0x00;	setup_packet[3] = 0x01;	setup_packet[4] = 0x00;	setup_packet[5] = 0x00;	setup_packet[6] = 0x12;	setup_packet[7] = 0x00;	OHCI_GeneralTD *td = OHCI_GeneralTD_Create();		OHCI_GeneralTD_Init(td, 0, setup_packet, 8);	OHCI_TD_SetDataToggle(td, 2);	OHCI_ED_AttachTD(device->listControl, td);		OHCI_GeneralTD_Init(td, 2, response, 8);	OHCI_TD_SetDataToggle(td, 3);	OHCI_ED_AttachTD(device->listControl, td);		OHCI_GeneralTD_Init(td, 2, response+8, 8);	OHCI_TD_SetDataToggle(td, 2);	OHCI_ED_AttachTD(device->listControl, td);		OHCI_ED_SetFunctionAddress(device->listControl, 0);	OHCI_ED_SetMaxPacketSize(device->listControl, 64);	//OHCI_ED_DumpInfo(device->listControl);	//OHCI_TD_DumpList(OHCI_ED_GetHeadP(device->listControl));	CheckpointIO(device->ioPrepTable.preparationID, kNextIOIsOutput|kMoreIOTransfers);	printf("*** Triggering control list processing...\n");	UInt32 commandStatus = OHCI_GetRegisterValue(device, OHCI_REG_HCCOMMANDSTATUS);	commandStatus |= 0x02; // control list filled	OHCI_SetRegisterValue(device, OHCI_REG_HCCOMMANDSTATUS, commandStatus);		CheckpointIO(device->ioPrepTable.preparationID, kNextIOIsOutput|kMoreIOTransfers);		DelayFor(5);			//OHCI_ED_DumpInfo(pciSonnet.ohci.listControl);	//OHCI_TD_DumpList(OHCI_ED_GetHeadP(pciSonnet.ohci.listControl));	printf("*** descriptor ***\n");	OHCI_DeviceDescriptor *devDesc = (OHCI_DeviceDescriptor *)response;	printf("Type		: %d\n", devDesc->bDescriptorType);	printf("USB Version : USB %X.%X\n", EndianU16_LtoB(devDesc->bcdUSB) >> 8, EndianU16_LtoB(devDesc->bcdUSB) & 0xFF);	printf("Class		: 0x%02X\n", devDesc->bDeviceClass);	printf("Subclass	: 0x%02X\n", devDesc->bDeviceSubClass);	printf("Packet Size	: %d\n", devDesc->bMaxPacketSize);	printf("Vendor		: 0x%04X\n", EndianU16_LtoB(devDesc->idVendor));	printf("Product		: 0x%04X\n", EndianU16_LtoB(devDesc->idProduct));	printf("Device ID   : 0x%04X\n", EndianU16_LtoB(devDesc->bcdDevice));}void OHCI_EVENT_PortStatusChanged(OHCI_Device *device){	printf("*** Port status changed ***\n");		// Loop through the root hub ports looking for a port with a changed status.	for(int i=1; i<device->rootPortCount; i++)	{		UInt32 portStatus = OHCI_GetRegisterValue(device, (OHCI_RegisterIndex)(OHCI_REG_HCRHPORTSTATUS_0+i));					if(portStatus & OHCI_PORTSTATUS_CSC)		{			// Connection status changed!			Boolean oldStatus = device->ports[i].connected;			Boolean newStatus = (portStatus & OHCI_PORTSTATUS_CCS);						printf("Port %d connection status: %d -> %d\n", i, oldStatus, newStatus);						device->ports[i].connected = newStatus;						portStatus |= OHCI_PORTSTATUS_PESC;			OHCI_SetRegisterValue(device, (OHCI_RegisterIndex)(OHCI_REG_HCRHPORTSTATUS_0+i), portStatus);					if(newStatus == 1) // Newly-connected device.			{				OHCI_EVENT_DeviceConnected(device, i);			}		}	}}